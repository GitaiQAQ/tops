/*
 *       TrainHMMMaximumLikelihood.cpp
 *
 *       Copyright 2011 Andre Yoshiaki Kashiwabara <akashiwabara@usp.br>
 *                      Ígor Bonádio <ibonadio@ime.usp.br>
 *                      Vitor Onuchic <vitoronuchic@gmail.com>
 *                      Alan Mitchell Durham <aland@usp.br>
 *
 *       This program is free software; you can redistribute it and/or modify
 *       it under the terms of the GNU  General Public License as published by
 *       the Free Software Foundation; either version 3 of the License, or
 *       (at your option) any later version.
 *
 *       This program is distributed in the hope that it will be useful,
 *       but WITHOUT ANY WARRANTY; without even the implied warranty of
 *       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *       GNU General Public License for more details.
 *
 *       You should have received a copy of the GNU General Public License
 *       along with this program; if not, write to the Free Software
 *       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 *       MA 02110-1301, USA.
 */
#include <sstream>
#include "Symbol.hpp"
#include "ProbabilisticModel.hpp"
#include "ProbabilisticModelCreator.hpp"
#include "ConfigurationReader.hpp"
#include "TrainHMMMaximumLikelihood.hpp"
#include "TrainFixedLengthMarkovChain.hpp"
#include  "VariableLengthMarkovChain.hpp"
#include "util.hpp"
#include "ProbabilisticModelCreatorClient.hpp"
namespace tops {

  ProbabilisticModelPtr TrainHMMMaximumLikelihood::create( ProbabilisticModelParameters & parameters) const
  {
    ProbabilisticModelParameterValuePtr alphabetpar = parameters.getMandatoryParameterValue("observation_symbols");
    ProbabilisticModelParameterValuePtr statespar = parameters.getMandatoryParameterValue("state_names");
    ProbabilisticModelParameterValuePtr observation_file = parameters.getMandatoryParameterValue("observation_file");
    ProbabilisticModelParameterValuePtr states_file = parameters.getMandatoryParameterValue("states_file");
    ProbabilisticModelParameterValuePtr pseudocontspar = parameters.getOptionalParameterValue("pseudo_conter");

    if( (alphabetpar == NULL) || (statespar == NULL) || (observation_file == NULL) || (states_file == NULL) ) {
	    std::cerr << help() << std::endl;
	    exit(-1);
    }

    ProbabilisticModelCreatorClient client;
    AlphabetPtr alphabet = AlphabetPtr (new Alphabet());
    AlphabetPtr states = AlphabetPtr (new Alphabet());
    alphabet->initializeFromVector (alphabetpar->getStringVector());
    states->initializeFromVector(statespar->getStringVector());


    ProbabilisticModelParameters train_transitions;
    train_transitions.add("order", ProbabilisticModelParameterValuePtr (new IntParameterValue(1)));
    train_transitions.add("pseudo_counts", pseudocontspar);
    train_transitions.add("training_set", states_file);
    train_transitions.add("alphabet" , statespar);
    ProbabilisticModelPtr trans = client.create(train_transitions);
	    

    std::map<std::string,double> emisspar;
    std::map<std::string,double> transpar;
    std::map<std::string,double> initpar;
    std::map<std::string,double> estimatedprobpar = ((trans->parameters()).getMandatoryParameterValue("probabilities"))->getDoubleMap();
    std::map<std::string,double>::const_iterator it;  
    for(it = estimatedprobpar.begin(); it != estimatedprobpar.end(); it++) 
    {
	    std::vector<std::string> splited;
	    boost::regex separator ("\\|");
	    split_regex(it->first, splited, separator);
	    if(splited.size() == 1)
		   splited.push_back("");
	    std::string to (splited[0]);
	    std::string from (splited[1]);
	    if(from.size() == 0) 
		    initpar[to] = it->second;
	    else 
		    transpar[it->first] = it->second;
    }

    SequenceEntryList observations;
    SequenceEntryList states_seq;
    readSequencesFromFile(observations, alphabet, observation_file->getString());
    readSequencesFromFile(states_seq, states, states_file->getString());
    Matrix E (states->size(), alphabet->size()); 
    for(int s = 0; s < states->size(); s++)
	    for(int o = 0; o < alphabet->size(); o++)
		    E(s,o) = pseudocontspar->getDouble();

    for(int i = 0; (i < states_seq.size()) && (i < observations.size()); i++) {
	    Sequence obsseq = observations[i]->getSequence();
	    Sequence staseq = states_seq[i]->getSequence();
	    for(int j = 0; j < (j < obsseq.size()) && (j < staseq.size()); j++) 
		   E(staseq[j], obsseq[j]) += 1.0; 

    } 

    for(int s = 0; s < states->size(); s++){
	    double sum = 0;
	    for(int o = 0; o < alphabet->size(); o++)
		    sum += E(s,o);
	    for(int o = 0; o < alphabet->size(); o++)
		    E(s,o) /= sum;
    }
    for(int s = 0; s < states->size(); s++)
	    for(int o = 0; o < alphabet->size(); o++){
		    stringstream aux;
		    aux << alphabet->getSymbol(o)->name() << "|" << states->getSymbol(s)->name();
		    emisspar[aux.str()] = E(s,o);
	    }
		

    ProbabilisticModelParameters hmm_parameters;
    hmm_parameters.add("observation_symbols", alphabetpar);
    hmm_parameters.add("state_names", statespar);
    hmm_parameters.add("transitions", ProbabilisticModelParameterValuePtr(new DoubleMapParameterValue(transpar)));
    hmm_parameters.add("initial_probabilities",ProbabilisticModelParameterValuePtr(new DoubleMapParameterValue (initpar)));
    hmm_parameters.add("emission_probabilities",ProbabilisticModelParameterValuePtr(new DoubleMapParameterValue (emisspar)));
    ProbabilisticModelPtr m = client.create(hmm_parameters);
    return m;

  }
};



